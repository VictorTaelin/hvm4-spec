currently, the metal/hvm4.swift file is performing just about ~0.8 MIPS in a single core.

  Threads|Time|Interactions|MIPS
  1|0.582675|458816|0.79
  2|0.589769|917632|1.56
  4|0.586806|1835264|3.13
  8|0.603574|3670528|6.08
  16|0.605839|7341056|12.12
  32|0.628287|14682112|23.37
  64|0.613969|29364224|47.83
  128|0.613583|58728448|95.71
  256|0.635814|117456896|184.73
  512|0.687185|234913792|341.85
  1024|1.055127|469827584|445.28

  it is, at least, scaling well. but we believe that, with proper optimizations, we could reach 2 mips in 1 thread, 4 mips in 2 threads, and so on. your goal is to optimize the file towards that goal. keep in mind that this application is memory
  bottlenecked, and the inner loops are wnf() and the interactions (app_lam etc.), so, adjusting the memory layout, usage patterns, and optimizing the wnf() loop are the most effective interventions. do not inline functions - the compiler does that
  already, and doing so results in code explosion. that is never needed in a modern chip. we're on apple m4 max, 128 gb memory.
